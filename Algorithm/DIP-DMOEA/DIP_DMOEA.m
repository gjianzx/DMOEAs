function res= DIP_DMOEA(Problem,popSize,MaxIt,T_parameter,group,Algs_name)
res = cell(1,floor(T_parameter(group,3)/T_parameter(group,2)));
nt = T_parameter(group,1);
Tt = T_parameter(group,2);
for T = 1:floor(T_parameter(group,3)/T_parameter(group,2))  % 算法的总迭代次数 30  相当于环境变化了30次
        tic;
        t = 1/T_parameter(group,1)*(T-1);     % 函数的动态变化时间变量t----0  0.1  0.2  0.3 ... 3
        fprintf(' %d',T);
        
        if T <= 2  % 前两代
            [~,Pareto,POF_iter] = moead(Problem,popSize,MaxIt,t); 
            All_POS{T} = Pareto.X;   % pareto解集的位置
            All_POF{T} = Pareto.F;   % pareto解集的适应值
        else
            % 将过去两个连续的变化阶段作为输出，得到预测后新环境的初始种群
            [initPop,his_POS,curr_POS,pre_Pop] = DIP_prediction(All_POS{T-1}',All_POF{T-1}',All_POS{T-2}',All_POF{T-2}',Problem,popSize);
          
            initPop = unique(initPop','rows','stable')';  % 去除矩阵initPop重复的列，并保持原始列的顺序。
            pre_Pop = unique(pre_Pop','rows','stable')';
            LastPOS = unique(All_POS{T-1}','rows','stable')';
            
            % if size of initPop (generated by DIP) smaller than popsize, 
            % solutions generated by ANN will add into the initPop
            % 如果通过DIP产生的initPop的大小小于预定的种群大小，通过ANN产生的预测解也将添加到initPop中
            initPop = [initPop pre_Pop LastPOS];
            if size(initPop,2)>popSize
                initPop = initPop(:,1:popSize);
            end
        [~,Pareto,POF_iter] = moead(Problem,popSize,MaxIt,t,initPop);  % 获取新环境下的Pareto解集和前沿
        All_POS{T} = Pareto.X;    % 记录每次迭代的Pareto解集的位置和适应值
        All_POF{T} = Pareto.F;
        
        end
        res{T}.rt = toc;
        res{T}.turePOF=getBenchmarkPOF(Problem.Name,group,T,T_parameter );   % 获取当前测试函数的真实Pareto前沿
        res{T}.POF_iter=POF_iter;
        res{T}.POS=Pareto.X;
end
end





                    